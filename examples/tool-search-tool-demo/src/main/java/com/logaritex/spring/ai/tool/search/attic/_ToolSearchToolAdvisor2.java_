/*
* Copyright 2025 - 2025 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
package com.example.tool.attic;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.example.tool.search.catalog.ToolCatalog;
import com.example.tool.search.retriever.ToolReferenceRetriever;

import org.springframework.ai.chat.client.ChatClientRequest;
import org.springframework.ai.chat.client.ChatClientResponse;
import org.springframework.ai.chat.client.advisor.api.CallAdvisor;
import org.springframework.ai.chat.client.advisor.api.CallAdvisorChain;
import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.ai.chat.messages.AssistantMessage.ToolCall;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.ToolResponseMessage;
import org.springframework.ai.chat.model.Generation;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.model.ModelOptionsUtils;
import org.springframework.ai.model.tool.ToolCallingChatOptions;
import org.springframework.ai.tool.ToolCallback;
import org.springframework.ai.tool.definition.DefaultToolDefinition;
import org.springframework.ai.tool.definition.ToolDefinition;
import org.springframework.ai.util.json.JsonParser;
import org.springframework.ai.util.json.schema.JsonSchemaGenerator;
import org.springframework.core.Ordered;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;

/**
 * @author Christian Tzolov
 */
public class ToolSearchToolAdvisor2 implements CallAdvisor {

	private final static ToolDefinition TOOL_SEARCH_TOOL_DEFINITION = DefaultToolDefinition.builder()
		.name("toolSearchTool")
		.description("Finds additional tools for providing realtime information")
		.inputSchema(JsonSchemaGenerator.generateForType(ToolSearchRequest.class))
		.build();

	private final static ToolCallback TOOL_SEARCH_TOOL_CALLBACK = new ToolCallback() {

		@Override
		public ToolDefinition getToolDefinition() {
			return TOOL_SEARCH_TOOL_DEFINITION;
		}

		@Override
		public String call(String toolInput) {
			throw new UnsupportedOperationException("Unimplemented method 'call'");
		}

	};

	private final ToolReferenceRetriever toolRetriever;

	private final ToolCatalog toolCatalog;

	/**
	 * Set the order close to {@link Ordered#LOWEST_PRECEDENCE} to ensure an advisor is
	 * executed first in the chain (first for request processing, last for response
	 * processing).
	 * <p>
	 * https://docs.spring.io/spring-ai/reference/api/advisors.html#_advisor_order
	 */
	private final int advisorOrder;

	public ToolSearchToolAdvisor2(int advisorOrder, ToolReferenceRetriever toolRetriever, ToolCatalog toolCatalog) {
		this.advisorOrder = advisorOrder;
		this.toolRetriever = toolRetriever;
		this.toolCatalog = toolCatalog;
	}

	@Override
	public String getName() {
		return "Tool Calling Advisor";
	}

	@Override
	public int getOrder() {
		return this.advisorOrder;
	}

	@Override
	public ChatClientResponse adviseCall(ChatClientRequest chatClientRequest, CallAdvisorChain callAdvisorChain) {

		Assert.notNull(callAdvisorChain, "callAdvisorChain must not be null");
		Assert.notNull(chatClientRequest, "chatClientRequest must not be null");

		// Only proceed if Tool Calling is enabled
		if (chatClientRequest.prompt().getOptions() == null
				|| !(chatClientRequest.prompt().getOptions() instanceof ToolCallingChatOptions)) {

			return callAdvisorChain.nextCall(chatClientRequest);
		}

		List<ToolCallback> selectedTools = new ArrayList<>(List.of(TOOL_SEARCH_TOOL_CALLBACK));

		ToolCallingChatOptions toolOptions = (ToolCallingChatOptions) chatClientRequest.prompt().getOptions();

		// Register tools in the retriever index
		toolOptions.getToolCallbacks().forEach(tc -> {
			var defintion = tc.getToolDefinition();
			if (!this.toolCatalog.contains(defintion.name())) {
				this.toolCatalog.add(tc);
				this.toolRetriever.addTool(defintion.name(), defintion.description());
			}
		});

		Prompt promptWithAugmentedSysMessage = chatClientRequest.prompt()
			.copy()
			.augmentSystemMessage(systemMessage -> systemMessage.copy().mutate().text(systemMessage.getText() + """
					Note: You have access to additional tools via the toolSearchTool.
					Use it whenever you need to get real-time information or reach the outside world.
					""").build());

		boolean isToolSearchCall = false;
		ChatClientResponse chatClientResponse = null;

		List<String> toolReferences = new ArrayList<>();

		do {

			toolReferences.stream().forEach(toolName -> {
				if (this.toolCatalog.contains(toolName)) {
					selectedTools.add(this.toolCatalog.get(toolName));
				}
			});

			ToolCallingChatOptions toolOptionsCopy = toolOptions.copy();
			toolOptionsCopy.setToolCallbacks(selectedTools);

			var augmentedChatClientRequest = chatClientRequest.mutate()
				.prompt(promptWithAugmentedSysMessage.mutate().chatOptions(toolOptionsCopy).build())
				.build();

			// Next Call
			printUser("USER", augmentedChatClientRequest.prompt().getInstructions(),
					toolOptionsCopy.getToolCallbacks().stream().map(tc -> tc.getToolDefinition().name()).toList());

			chatClientResponse = callAdvisorChain.copy(this).nextCall(augmentedChatClientRequest);

			printAssistant("ASSISTANT", chatClientResponse.chatResponse().getResults());

			if (!chatClientResponse.chatResponse().hasToolCalls()) {
				return chatClientResponse;
			}

			List<ToolCall> toolSearchCalls = chatClientResponse.chatResponse()
				.getResults()
				.stream()
				.map(g -> g.getOutput())
				.filter(m -> m.hasToolCalls())
				.map(m -> m.getToolCalls())
				.flatMap(List::stream)
				.filter(tc -> tc.name().equals(TOOL_SEARCH_TOOL_DEFINITION.name()))
				.toList();

			isToolSearchCall = false;
			
			List<ToolResponseMessage.ToolResponse> toolResponseMessages  = new ArrayList<>();

			if (!CollectionUtils.isEmpty(toolSearchCalls)) {
				isToolSearchCall = true;

				toolSearchCalls.forEach(toolSearchCall -> {
					ToolSearchRequest toolSearchRequest = JsonParser.fromJson(toolSearchCall.arguments(),
							ToolSearchRequest.class);
					
					List<String> toolNameReferences = this.toolRetriever.findTools(toolSearchRequest.query());

					toolReferences.addAll(toolNameReferences);
					
					toolResponseMessages.add(new ToolResponseMessage.ToolResponse(toolSearchCall.id(), toolSearchCall.name(),
							JsonParser.toJson(toolNameReferences)));
				});
			}

			List<Message> messages = new ArrayList<>(chatClientRequest.prompt().getInstructions());

			messages.addAll(chatClientResponse.chatResponse()
				.getResults()
				.stream()
				.map(g -> g.getOutput()).toList());
				// .filter(m -> m.hasToolCalls()).toList());

			messages.add(ToolResponseMessage.builder().responses(toolResponseMessages).build());
			
			promptWithAugmentedSysMessage = promptWithAugmentedSysMessage.mutate()
				.messages(messages)
				.build();
			
		}
		while (isToolSearchCall);

		return chatClientResponse;
	}

	public record ToolSearchRequest(String query) {
	}

	private void printUser(String label, List<Message> messages, Object tools) {
		String mt = messages.stream()
			.map(m -> "    - " + ModelOptionsUtils.toJsonString(m))
			.collect(Collectors.joining("\n"));
		System.out.println("\n" + label + ":\n" + mt + "\n   TOOLS: " + ModelOptionsUtils.toJsonString(tools) + "\n");
	}

	private void printAssistant(String label, List<Generation> generations) {
		String gt = generations.stream()
			.map(g -> "    - " + ModelOptionsUtils.toJsonString(g.getOutput()))
			.collect(Collectors.joining("\n"));
		System.out.println("\n" + label + ":\n" + gt + "\n");
	}

}
